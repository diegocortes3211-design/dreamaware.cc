--- a/.github/issue_seeds.yaml
+++ b/.github/issue_seeds.yaml
@@ -0,0 +1,123 @@
+issues:
+  - title: "CODE_AGENT: Void Chain Receipt Logger"
+    labels: ["autopilot","CODE_AGENT","voidchain","receipts"]
+    body: |
+      Goal
+      Add Merkle-style receipt logging stubs (TS/Go/Python), attach to CI artifacts.
+
+      Tasks
+      - [ ] Create `voidchain/verify.ts` with `logReceipt`
+      - [ ] Add Go shim `services/voidchain/verify.go`
+      - [ ] Add Python shim `services/voidchain/verify.py`
+      - [ ] CI: attach `receipt.json` on each PR
+
+      *** Add File: voidchain/verify.ts
+      ```ts
+      import { createHash } from "crypto";
+      export function logReceipt(data: any): string {
+        const payload = JSON.stringify(data);
+        return createHash("sha256").update(payload).digest("hex");
+      }
+      ```
+
+      *** Add File: services/voidchain/verify.py
+      ```python
+      import json, hashlib, sys
+      def log_receipt(obj) -> str:
+          payload = json.dumps(obj, sort_keys=True).encode()
+          return hashlib.sha256(payload).hexdigest()
+      if __name__ == "__main__":
+          data = json.loads(sys.stdin.read() or "{}")
+          print(log_receipt(data))
+      ```
+
+      *** Add File: services/voidchain/verify.go
+      ```go
+      package voidchain
+      import (
+        "crypto/sha256"
+        "encoding/hex"
+        "encoding/json"
+      )
+      func LogReceipt(v any) string {
+        b, _ := json.Marshal(v)
+        sum := sha256.Sum256(b)
+        return hex.EncodeToString(sum[:])
+      }
+      ```
+
+  - title: "DOCS_AGENT: Ethics & Human Factors Playbook"
+    labels: ["autopilot","DOCS_AGENT","docs","ethics"]
+    body: |
+      Goal
+      Establish IC-aligned ethics and human-factors docs with actionable drills.
+
+      Tasks
+      - [ ] Create `docs/ethics.md` (IC principles, bias tests, privacy)
+      - [ ] Add `docs/humanfactorsplaybook.md` (drills, meditations, SERE-tabletops)
+      - [ ] Link from README
+
+      *** Add File: docs/ethics.md
+      ```markdown
+      # Ethics & Transparency (IC-aligned)
+      - Respect the law & integrity
+      - Transparent & accountable (XAI + audit trails)
+      - Objective & equitable (bias testing playbook)
+      - Human-centered (HITL for high-risk changes)
+      - Secure & resilient (DevSecOps + adversarial testing)
+      - Informed by science (NIST-aligned)
+      ```
+
+      *** Add File: docs/humanfactorsplaybook.md
+      ```markdown
+      # Human Factors Playbook
+      - Compartmentalization drills
+      - Mindfulness: 3x3 breath protocol
+      - SERE-style tabletop: incident rehearsal
+      - Peer feedback cadence & psychological safety checklist
+      ```
+
+  - title: "SCORECARD: Xikizpedia Weights & Thresholds"
+    labels: ["autopilot","xikizpedia","scorecard","config"]
+    body: |
+      Goal
+      Add initial weights/thresholds for text/video/audio analyzers.
+
+      Tasks
+      - [ ] Create `config/xikizpedia.yaml`
+      - [ ] Wire into score aggregation if present
+      - [ ] Add CI smoke read of config
+
+      *** Add File: config/xikizpedia.yaml
+      ```yaml
+      weights:
+        slop: 0.25
+        trauma: 0.25
+        body: 0.25
+        pause: 0.25
+      slop_thresholds:
+        emoji_max: 8
+        emdash_max: 12
+        endash_max: 12
+      pause:
+        normalize_divisor: 1.0
+      ```
+
+  - title: "SOCRATIC_AGENT: Slop Rules & Questions"
+    labels: ["autopilot","Socratic","scorecard"]
+    body: |
+      Goal
+      Define rule set to drive Socratic questions and scoring bands.
+
+      Tasks
+      - [ ] Add `services/scorecard/slop_rules.yaml` with bands
+      - [ ] Ensure SocraticAgent loads rules if present
+
+      *** Add File: services/scorecard/slop_rules.yaml
+      ```yaml
+      bands:
+        emoji:
+          low:    { max: 3,   note: "natural" }
+          medium: { max: 8,   note: "stylized" }
+          high:   { max: 999, note: "likely AI-stylized" }
+        dash:
+          emdash:
+            low:    { max: 6 }
+            medium: { max: 12 }
+            high:   { max: 999 }
+      prompts:
+        - "Why do em-dashes appear here? Can clarity improve with shorter sentences?"
+        - "Are emojis conveying meaning or padding tone?"
+      ```
+
+  - title: "DABench: Threshold Tuning & Branch Protection"
+    labels: ["DABench","CI","governance"]
+    body: |
+      Goal
+      Tune U/C/S bars and enforce via branch protection.
+
+      Tasks
+      - [ ] Decide min Utility/Safety, max Cost per repo area
+      - [ ] Update branch protection to require DABench
+      - [ ] Add badge to submodules if any
+
+  - title: "Commit Digest: Confirm Schedule & Recipients"
+    labels: ["commit-digest","automation"]
+    body: |
+      Goal
+      Validate twice-daily digest and Slack/Discussion targets.
+
+      Tasks
+      - [ ] Confirm 02:00 & 14:00 UTC cadence
+      - [ ] Add Slack webhook (optional)
+      - [ ] Tag owners for follow-ups
+
+  - title: "SECURITY_AGENT: Expand OPA Coverage"
+    labels: ["SECURITY_AGENT","policy","CI"]
+    body: |
+      Goal
+      Extend `dreamaware.policy` with purpose-binding exceptions and per-module allowlists.
+
+      Tasks
+      - [ ] Add unit tests for exceptions (policy/*.rego)
+      - [ ] Gate new modules with purpose tags
+      - [ ] Report deny reasons into DABench Safety details
+
--- a/.github/workflows/seed-issues.yml
+++ b/.github/workflows/seed-issues.yml
@@ -0,0 +1,29 @@
+name: Seed Issues (manual)
+
+on:
+  workflow_dispatch:
+    inputs:
+      only_titles:
+        description: "Comma-separated titles to seed (optional)"
+        required: false
+        default: ""
+      dry_run:
+        description: "Print plan without creating"
+        required: false
+        default: "false"
+
+permissions:
+  contents: read
+  issues: write
+
+jobs:
+  seed:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up Python
+        uses: actions/setup-python@v5
+        with:
+          python-version: "3.11"
+      - name: Seed issues
+        id: seed
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          ONLY_TITLES: ${{ inputs.only_titles }}
+          DRY_RUN: ${{ inputs.dry_run }}
+        run: python scripts/seed_issues.py
+      - name: Summary
+        run: |
+          echo "Created: ${{ steps.seed.outputs.created_count || '0' }}"
+
--- a/scripts/seed_issues.py
+++ b/scripts/seed_issues.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python3
+"""
+Seed GitHub issues from .github/issue_seeds.yaml
+Idempotent: skips if an open issue with the same title already exists.
+Filters:
+  ONLY_TITLES="Title1,Title2"  -> create only matching titles
+  DRY_RUN="1"                  -> print plan only
+"""
+import os, sys, json, requests, yaml
+from pathlib import Path
+
+SEEDS = Path(".github/issue_seeds.yaml")
+REPO = os.environ.get("GITHUB_REPOSITORY", "")
+TOKEN = os.environ.get("GITHUB_TOKEN")
+ONLY = {t.strip() for t in os.environ.get("ONLY_TITLES", "").split(",") if t.strip()}
+DRY = os.environ.get("DRY_RUN", "0") in ("1","true","True","YES","yes")
+
+def gh(url, method="GET", **kw):
+    h = {"Authorization": f"Bearer {TOKEN}", "Accept": "application/vnd.github+json"}
+    return requests.request(method, url, headers=h, **kw)
+
+def main():
+    if not TOKEN:
+        print("ERROR: GITHUB_TOKEN not set", file=sys.stderr); sys.exit(2)
+    if not REPO:
+        print("ERROR: GITHUB_REPOSITORY not set", file=sys.stderr); sys.exit(2)
+    if not SEEDS.exists():
+        print("No seeds file found, skipping."); return
+    data = yaml.safe_load(SEEDS.read_text()) or {}
+    seeds = data.get("issues", [])
+
+    # fetch open issues (first 100)
+    base = f"https://api.github.com/repos/{REPO}"
+    cur = gh(f"{base}/issues?state=open&per_page=100").json()
+    open_titles = {i["title"] for i in cur if "pull_request" not in i}
+
+    created = []
+    for it in seeds:
+        title = it.get("title","").strip()
+        if not title: continue
+        if ONLY and title not in ONLY:
+            continue
+        if title in open_titles:
+            print(f"skip (exists): {title}")
+            continue
+        body = it.get("body","")
+        labels = it.get("labels",[])
+        payload = {"title": title, "body": body, "labels": labels}
+        if DRY:
+            print(f"DRY: would create issue: {title} labels={labels}")
+            continue
+        r = gh(f"{base}/issues", method="POST", json=payload)
+        if r.status_code >= 300:
+            print(f"ERROR creating '{title}': {r.status_code} {r.text}", file=sys.stderr)
+        else:
+            num = r.json()["number"]
+            created.append(num)
+            print(f"created #{num}: {title}")
+
+    # outputs for workflows
+    gout = os.environ.get("GITHUB_OUTPUT")
+    if gout:
+        with open(gout,"a") as f:
+            f.write(f"created_count={len(created)}\n")
+            f.write(f"created_numbers={','.join(map(str,created))}\n")
+
+if __name__ == "__main__":
+    main()